<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>textcontent & innerText</title>
</head>
<body>
  <div class="wrap">
    <style>
      p{
        /* color: red; */
      }
    </style>
    <script>
      console.log('sdd')
    </script>
    <p>
      this is p1!
      <span> this is p1-span!</span>
    </p>
    <p>
      this is p2!
      <span> this is p2-span!</span>
    </p>
    <!-- p -->
  </div>
  <div>
    <p>
      <strong> Node.textContent vs HTMLElement.innerText</strong>
      不要被 Node.textContent 和 HTMLElement.innerText 的区别搞混了。虽然名字看起来很相似，但有重要的不同之处：
      textContent 会获取所有元素的内容，包括 'script' 和 'style' 元素，然而 innerText 只展示给人看的元素。
      textContent 会返回节点中的每一个元素。相反，innerText 受 CSS 样式的影响，并且不会返回隐藏元素的文本，
      此外，由于 innerText 受 CSS 样式的影响，它会触发回流（ reflow ）去确保是最新的计算样式。（回流在计算上可能会非常昂贵，因此应尽可能避免。）
    </p>
    <p>
        <strong>Node.textContent vs </strong>
        正如其名称，Element.innerHTML 返回 HTML。通常，为了在元素中检索或写入文本，人们使用 innerHTML。但是，textContent 通常具有更好的性能，因为文本不会被解析为 HTML。
        此外，使用 textContent 可以防止 XSS 攻击。
    </p>
    <figure>
      <pre role="img" aria-label="ASCII COW">
          ___________________________
      &lt; I'm an expert in my field. &gt;
          ---------------------------
              \   ^__^
                \  (oo)\_______
                  (__)\       )\/\
                      ||----w |
                      ||     ||
      </pre>
      <figcaption id="cow-caption">
        A cow saying, "I'm an expert in my field." The cow is illustrated using
        preformatted text characters.
      </figcaption>
    </figure>
      
  </div>
  <script>
    const wrap = document.querySelector('.wrap')
    console.log('textcontent',wrap.textContent) 
    console.log('innerHtml',wrap.innerHTML)
    console.log('innerHtml',wrap.innerTetx)
  </script>
</body>
</html>